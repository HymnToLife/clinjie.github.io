title: 阻塞/非阻塞&同步/异步
date: 2016-11-14 23:28:30
tags:
- 网络
categories: 网络
---


# 同步/异步 #

>[The Sockets Networking API](http://library.tebyan.net/en/Viewer/Text/164873/92)

同步和异步的区别在于，做一件事情，消息通知的流程。在同步中，是由发起者（调用者）主动等待消息反应，而异步情况则是有被动者（被调用者）通过反馈机制通知发起者来处理返回的消息

所以区分同步与异步，主要是消息处理前的行为

# 阻塞/非阻塞 #

阻塞是在调用结果返回之前，当前**线程/进程**将会被挂起，直到结果返回才会继续执行。

非阻塞情况不会阻塞当前线程，该线程还可以执行。

所以阻塞与非阻塞的关注点应该在于发出请求之后，请求未返回之前这段时间，线程是否有能力（被允许）执行之后的任务

阻塞是由系统自动执行阻塞原语(block)，使自己由运行状态变为阻塞状态。进程进入阻塞状态之后，不会占用CPU资源

# coroutine与异步回调 #
<!--more-->
## 协程 ##

coroutine即协程，是实现类异步执行的一种方式。 协程是什么呢，协程实际上是一种比线程更小的执行单元，自带context，协程实现类异步也是通过不断的切换；相比线程，协程仅仅是保持着cpu context，而进程一直维持着cache、断点等很多消耗时间、内存的地方。

协程的一些缺点：虽然相比线程来讲，减少了很多cache等数据维持，实际上context与线程相比并没有太多的提升，如果task是CPU密集型，使用协程可以看到很好的效果，I/O密集型则不会有很大改观，因为依然是阻塞式；协程是非系统层面感知的，无法使用系统的进程调度，我们只能主动的在协程的上层线程中重造调度器来实现协程间的调度；


解决：低速I/O与高速CPU协调问题

## 异步回调 ##

这是一种比较常见的异步使用方式，发起方调用任务，并设置指定的回调函数；调用方和被调用处于不同的线程中，调用方发起并启动新的被调用线程后继续执行后面的task，新线程执行完指定的调用任务后，通过多种消息通知方法通知调用方，这样调用放就能够继续执行异步调用数据。

缺点：将原有逻辑上整体的蛋糕强行分成了两部分甚至更多，这样不是很符合人类的逻辑理解。多个回调之间耦合性太高


异步的实现可以使用多线程，也可以将任务交给其他进程处理





